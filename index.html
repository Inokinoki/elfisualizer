<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>elfisualize - an ELF Visualizer</title>
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline';" />
</head>
<body style="background: white;">
    <p>
        <span id="status">Nothing loaded</span>
    </p>
    <button onclick="open_file()">Open ELF File</button>
    <br/>
    <canvas id="elf-layout" width="550" height="60"></canvas>
    <canvas id="elf-programs" width="550" height="60"></canvas>
    <canvas id="elf-sections" width="550" height="60"></canvas>
    <script>
        const { ipcRenderer } = require('electron');

        async function open_file(params) {
            const statusText = document.getElementById("status")
            statusText.innerText = "Loading...";
            const result = await ipcRenderer.invoke('load-file');
            if (result.name) {
                if (result.elf) {
                    // Loaded
                    statusText.innerText = "ELF file \"" + result.name
                        + "\"(size " + result.size + "B) loaded";
                    const elfisualized = elfisualize(result.elf, result.size);
                    visualize(elfisualized, document.getElementById("elf-layout"),
                        document.getElementById("elf-programs"), document.getElementById("elf-sections"));
                } else {
                    // Not loaded
                    statusText.innerText = "No ELF file loaded";
                }
            } else {
                // Nothing
                statusText.innerText = "Nothing loaded";
            }
        }

        function elfisualize(elf, size) {
            if (elf == null) return { size: 0, header: null, programs: [], sections: [] };

            let result = { size: size, programs: [], sections: [],
                header: elf.header };

            // Parse programs and sections
            console.log(elf);

            // Append programs
            elf.programs.map(function(program) {
                result.programs.push(program.header);
            });

            // Append sections
            elf.sections.map(function(section) {
                result.sections.push(section.header);
            });

            return result;
        }
        const LAYOUT_CANVAS_BEGIN_X = 25;
        const LAYOUT_CANVAS_BEGIN_Y = 0;
        const LAYOUT_CANVAS_HEIGHT = 40;
        const LAYOUT_CANVAS_WIDTH = 500;
        const LAYOUT_HEIGHT = 60;
        const LAYOUT_MARGIN = 5;

        function visualize(elfisualizedELF, layout_canvas, programs_canvas, sections_canvas) {
            let textMetrix;
            console.log(layout_canvas);
            const layout_ctx = layout_canvas.getContext('2d');
            console.log(layout_ctx);
            // Block
            layout_ctx.moveTo(LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_BEGIN_Y);
            layout_ctx.lineTo(LAYOUT_CANVAS_BEGIN_X , LAYOUT_CANVAS_HEIGHT);
            layout_ctx.lineTo(LAYOUT_CANVAS_WIDTH + LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_HEIGHT);
            layout_ctx.lineTo(LAYOUT_CANVAS_WIDTH + LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_BEGIN_Y);
            layout_ctx.lineTo(LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_BEGIN_Y);
            layout_ctx.lineWidth = 1;
            layout_ctx.stroke();
            textMetrix = layout_ctx.measureText("0");
            layout_ctx.fillText("0", LAYOUT_CANVAS_BEGIN_X - textMetrix.width / 2, LAYOUT_HEIGHT - LAYOUT_MARGIN);
            textMetrix = layout_ctx.measureText(elfisualizedELF.size);
            layout_ctx.fillText(elfisualizedELF.size,
                LAYOUT_CANVAS_BEGIN_X + LAYOUT_CANVAS_WIDTH - textMetrix.width / 2, LAYOUT_HEIGHT - LAYOUT_MARGIN);

            // Header
            layout_ctx.fillStyle = 'green';
            layout_ctx.fillRect(LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_BEGIN_Y,
                elfisualizedELF.header.ehsize, LAYOUT_CANVAS_HEIGHT);
            layout_ctx.fillStyle = 'black';
            textMetrix = layout_ctx.measureText("Header");
            layout_ctx.fillText("Header",
                LAYOUT_CANVAS_BEGIN_X + elfisualizedELF.header.ehsize / 2 - textMetrix.width / 2,
                LAYOUT_HEIGHT - LAYOUT_MARGIN);
            textMetrix = layout_ctx.measureText(elfisualizedELF.header.ehsize);
            layout_ctx.fillText(elfisualizedELF.header.ehsize,
                LAYOUT_CANVAS_BEGIN_X + elfisualizedELF.header.ehsize - textMetrix.width / 2, LAYOUT_HEIGHT - LAYOUT_MARGIN);

            // Program header
            layout_ctx.fillStyle = 'yellow';
            const phOffset = elfisualizedELF.header.phoff - elfisualizedELF.header.ehsize;
            layout_ctx.fillRect(LAYOUT_CANVAS_BEGIN_X + elfisualizedELF.header.ehsize +
                phOffset * LAYOUT_CANVAS_WIDTH / elfisualizedELF.size, LAYOUT_CANVAS_BEGIN_Y,
                4 * elfisualizedELF.header.phnum, LAYOUT_CANVAS_HEIGHT);
            layout_ctx.fillStyle = 'black';
            textMetrix = layout_ctx.measureText(elfisualizedELF.header.phnum + " PH");
            layout_ctx.fillText(elfisualizedELF.header.phnum + " PH",
                LAYOUT_CANVAS_BEGIN_X + elfisualizedELF.header.ehsize +
                phOffset * LAYOUT_CANVAS_WIDTH / elfisualizedELF.size +
                4 * elfisualizedELF.header.phnum / 2 - textMetrix.width / 2,
                LAYOUT_HEIGHT - LAYOUT_MARGIN);
            const phEndOffset = elfisualizedELF.header.phoff
                + elfisualizedELF.header.phentsize * elfisualizedELF.header.phnum;
            textMetrix = layout_ctx.measureText(phEndOffset + "");
            layout_ctx.fillText(phEndOffset + "",
                LAYOUT_CANVAS_BEGIN_X + elfisualizedELF.header.ehsize +
                phOffset * LAYOUT_CANVAS_WIDTH / elfisualizedELF.size +
                4 * elfisualizedELF.header.phnum - textMetrix.width / 2,
                LAYOUT_HEIGHT - LAYOUT_MARGIN);

            // Section header
            layout_ctx.fillStyle = 'yellow';
            const shOffset = elfisualizedELF.header.shoff
                + elfisualizedELF.header.shentsize * elfisualizedELF.header.shnum;
            const shOffsetRight = (elfisualizedELF.size - shOffset) * LAYOUT_CANVAS_WIDTH / elfisualizedELF.size;
            layout_ctx.fillRect(LAYOUT_CANVAS_BEGIN_X + LAYOUT_CANVAS_WIDTH - shOffsetRight -
                4 * elfisualizedELF.header.shnum, LAYOUT_CANVAS_BEGIN_Y,
                4 * elfisualizedELF.header.shnum, LAYOUT_CANVAS_HEIGHT);
            layout_ctx.fillStyle = 'black';
            textMetrix = layout_ctx.measureText(elfisualizedELF.header.shnum + " SH");
            layout_ctx.fillText(elfisualizedELF.header.shnum + " SH",
                LAYOUT_CANVAS_BEGIN_X + LAYOUT_CANVAS_WIDTH - shOffsetRight -
                4 * elfisualizedELF.header.shnum + 4 * elfisualizedELF.header.shnum / 2 - textMetrix.width / 2,
                LAYOUT_HEIGHT - LAYOUT_MARGIN);
            textMetrix = layout_ctx.measureText(elfisualizedELF.header.shoff + "");
            layout_ctx.fillText(elfisualizedELF.header.shoff + "",
                LAYOUT_CANVAS_BEGIN_X + LAYOUT_CANVAS_WIDTH - shOffsetRight -
                4 * elfisualizedELF.header.shnum - textMetrix.width / 2,
                LAYOUT_HEIGHT - LAYOUT_MARGIN);

            if (programs_canvas) {
                // Visualized programs
                visualizeProgram(elfisualizedELF, programs_canvas);
            }
            if (sections_canvas) {
                // Visualized sections
                visualizeSection(elfisualizedELF, sections_canvas);
            }
        }

        function visualizeProgram(elfisualizedELF, layout_canvas) {
            let minOffset = elfisualizedELF.size, maxOffset = 0;
            elfisualizedELF.programs.map(function(program) {
                console.log(program);
                if (program.offset < minOffset) minOffset = program.offset;
                if (program.offset + program.filesz > maxOffset) maxOffset = program.offset + program.filesz;
            });
            console.log(minOffset, maxOffset);
            if (minOffset == elfisualizedELF) minOffset = 0;
            if (maxOffset == 0) maxOffset = elfisualizedELF.size;
            const layout_ctx = layout_canvas.getContext('2d');
            // Block
            layout_ctx.moveTo(LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_BEGIN_Y);
            layout_ctx.lineTo(LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_HEIGHT);
            layout_ctx.lineTo(LAYOUT_CANVAS_WIDTH + LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_HEIGHT);
            layout_ctx.lineTo(LAYOUT_CANVAS_WIDTH + LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_BEGIN_Y);
            layout_ctx.lineTo(LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_BEGIN_Y);
            layout_ctx.lineWidth = 1;
            layout_ctx.stroke();
            textMetrix = layout_ctx.measureText(minOffset + "");
            layout_ctx.fillText(minOffset + "", LAYOUT_CANVAS_BEGIN_X - textMetrix.width / 2, LAYOUT_HEIGHT - LAYOUT_MARGIN);
            textMetrix = layout_ctx.measureText(maxOffset + "");
            layout_ctx.fillText(maxOffset + "",
                LAYOUT_CANVAS_BEGIN_X + LAYOUT_CANVAS_WIDTH - textMetrix.width / 2, LAYOUT_HEIGHT - LAYOUT_MARGIN);
            
        }

        function visualizeSection(elfisualizedELF, layout_canvas) {
            let minOffset = elfisualizedELF.size, maxOffset = 0;
            elfisualizedELF.sections.map(function(section) {
                console.log(section);
                if (section.offset < minOffset) minOffset = section.offset;
                if (section.offset + section.filesz > maxOffset) maxOffset = section.offset + section.filesz;
            });
            console.log(minOffset, maxOffset);
            if (minOffset == elfisualizedELF) minOffset = 0;
            if (maxOffset == 0) maxOffset = elfisualizedELF.size;
            const layout_ctx = layout_canvas.getContext('2d');
            // Block
            layout_ctx.moveTo(LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_BEGIN_Y);
            layout_ctx.lineTo(LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_HEIGHT);
            layout_ctx.lineTo(LAYOUT_CANVAS_WIDTH + LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_HEIGHT);
            layout_ctx.lineTo(LAYOUT_CANVAS_WIDTH + LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_BEGIN_Y);
            layout_ctx.lineTo(LAYOUT_CANVAS_BEGIN_X, LAYOUT_CANVAS_BEGIN_Y);
            layout_ctx.lineWidth = 1;
            layout_ctx.stroke();
            textMetrix = layout_ctx.measureText(minOffset + "");
            layout_ctx.fillText(minOffset + "", LAYOUT_CANVAS_BEGIN_X - textMetrix.width / 2, LAYOUT_HEIGHT - LAYOUT_MARGIN);
            textMetrix = layout_ctx.measureText(maxOffset + "");
            layout_ctx.fillText(maxOffset + "",
                LAYOUT_CANVAS_BEGIN_X + LAYOUT_CANVAS_WIDTH - textMetrix.width / 2, LAYOUT_HEIGHT - LAYOUT_MARGIN);
        }
    </script>
</body>
</html>
